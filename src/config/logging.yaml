version: 1  # version du format de configuration du module logging (obligatoire pour le chargeur YAML)
disable_existing_loggers: false  # conserve les loggers déjà existants (utile quand des libs externes ont leur propre logger)

# Configuration du système de journalisation (logging) pour Ultramotion IGT Inference
#
# Politiques :
# - LOG_MODE=dev|perf contrôle la verbosité de la console (dev=INFO, perf=WARNING). Définie via la variable d’environnement LOG_MODE.
# - ASYNC_LOG=1|0 active ou désactive l’écriture asynchrone sur disque. Si ASYNC_LOG=1, le sous-système asynchrone devient l’unique écrivain pour les fichiers pipeline.log, kpi.log et error.log.
# - Le script de démarrage (main.py) est responsable de la création du répertoire `logs/` avant le chargement de ce fichier.
# - main.py ajuste automatiquement le niveau du handler console selon la variable LOG_MODE (LOG_MODE=dev → INFO, LOG_MODE=perf → WARNING). Ne pas modifier console.level ici : c’est main.py qui applique le réglage au lancement.
# - Convention : utiliser des noms de logger sous la hiérarchie `igt.*` (par exemple igt.service, igt.monitor, igt.kpi).

# ─────────────────────────────────────────────────────────────
# Politique console :
# LOG_MODE=dev  → console.level = INFO (ajusté au démarrage)
# LOG_MODE=perf → console.level = WARNING (par défaut)
# Le niveau console est toujours ajusté par main.py.
# Ne pas modifier ce champ manuellement.
# ─────────────────────────────────────────────────────────────
# ─────────────────────────────────────────────────────────────
# FORMATTERS
# ─────────────────────────────────────────────────────────────
formatters:
  standard:  # format principal pour logs console
    format: "[%(asctime)s] [%(levelname)s] %(processName)s/%(threadName)s | %(name)s | %(message)s"  # timestamp, niveau, nom thread, logger, message

  kpi:  # format spécialisé pour les métriques KPI
    format: "kpi ts_log=%(asctime)s %(message)s"  # ex: kpi ts_log=2025-10-28 11:33:12,888 latency_ms=12.3 fps_rx=30.0

# ─────────────────────────────────────────────────────────────
# FILTRES
# ─────────────────────────────────────────────────────────────
filters:
  perf_filter:  # filtre maison pour réduire la verbosité en mode perf
    '()': core.monitoring.filters.PerfFilter  # charge la classe PerfFilter depuis ton module
  no_error:  # filtre qui empêche duplication des erreurs (déjà redirigées vers error.log)
    '()': core.monitoring.filters.NoErrorFilter  # charge la classe NoErrorFilter

# ─────────────────────────────────────────────────────────────
# HANDLERS
# ─────────────────────────────────────────────────────────────
handlers:
  console:
    class: logging.StreamHandler  # Handler de sortie standard (affiche dans la console)
    formatter: standard  # Utilise le format standard défini pour l'affichage des logs
    level: WARNING  # Seulement les logs de niveau WARNING et supérieur seront affichés
    filters: [perf_filter]  # Applique le filtre pour réduire la verbosité en mode "perf"
  
  kpi_file:
    class: logging.FileHandler  # Handler pour l'écriture dans un fichier
    filename: "logs/kpi.log"  # Fichier où les métriques KPI seront enregistrées
    formatter: kpi  # Utilise le format kpi pour l'enregistrement des métriques
    level: INFO  # Seulement les logs de niveau INFO ou supérieurs seront enregistrés
    filters: [no_error]  # Applique un filtre pour éviter que les erreurs ne soient loguées dans ce fichier

  error_file:
    class: logging.FileHandler  # Handler pour l'écriture dans un fichier d'erreurs
    filename: "logs/error.log"  # Fichier où les erreurs seront enregistrées
    formatter: standard  # Utilise le format standard pour les logs d'erreurs
    level: ERROR  # Seulement les erreurs (niveau ERROR et CRITICAL) seront enregistrées

  pipeline_file:
    class: logging.FileHandler  # Handler pour l'écriture dans le fichier des logs généraux du pipeline
    filename: "logs/pipeline.log"  # Fichier où toutes les étapes du pipeline seront loguées
    formatter: standard  # Utilise le format standard pour l'enregistrement des logs
    level: DEBUG  # Enregistre tous les logs de niveau DEBUG et supérieur (logs détaillés pour toute l'exécution)
    filters: [no_error]  # Applique le filtre pour éviter que les erreurs soient dupliquées (elles vont déjà dans error.log)

# ─────────────────────────────────────────────────────────────
# LOGGERS PAR MODULE
# ─────────────────────────────────────────────────────────────

loggers:
  igt:
    level: INFO  # Niveau de log par défaut pour ce logger (log de niveau INFO et supérieur)
    handlers: [console, pipeline_file]  # Les logs seront envoyés à la console et au fichier pipeline.log
    propagate: no  # Empêche la propagation des logs vers les loggers parents (évite la duplication)

  igt.kpi:
    level: INFO  # Seuls les logs de niveau INFO et supérieur seront enregistrés pour ce logger
    handlers: [kpi_file]  # Les logs seront envoyés uniquement au fichier kpi.log (pour les métriques KPI)
    propagate: no  # Empêche la propagation vers les loggers parents pour éviter la duplication des logs dans d'autres fichiers

  igt.error:
    level: ERROR  # Seuls les logs de niveau ERROR et CRITICAL seront enregistrés pour ce logger
    handlers: [error_file]  # Les logs d'erreurs seront envoyés au fichier error.log
    propagate: no  # Empêche la propagation vers les loggers parents (cela garantit que seules les erreurs sont enregistrées ici)

  igt.service:
    level: INFO  # Niveau de log INFO, affichera des informations importantes mais pas les détails de débogage
    handlers: [pipeline_file, error_file]  # Envoie les logs à la console, pipeline.log et error.log (pour les erreurs)
    propagate: no  # Empêche la propagation des logs vers les loggers parents, ce qui évite les duplications

  igt.receiver:
    level: DEBUG  # Niveau de log DEBUG, utile pour capturer des informations détaillées sur la réception des données
    handlers: [console, pipeline_file, error_file]  # Envoie les logs à la console, pipeline.log et error.log (pour les erreurs)
    propagate: no  # Empêche la propagation vers les loggers parents afin de ne pas dupliquer les logs ailleurs

  igt.queues:  # gestion des files et buffers
    level: INFO
    handlers: [console, error_file]
    propagate: no

  igt.gpu:  # traitements GPU
    level: INFO
    handlers: [console]
    propagate: no

  igt.inference:  # moteur d'inférence IA (D-FINE, MobileSAM)
    level: INFO
    handlers: [console]
    propagate: no

  igt.slicer:  # thread TX vers 3D Slicer
    level: INFO
    handlers: [console]
    propagate: no

  igt.monitor:  # supervision et KPIs internes
    level: INFO
    handlers: [console]
    propagate: no

  igt.types:  # structures et dataclasses
    level: DEBUG
    handlers: [console]
    propagate: no

  igt.fsm:  # machine à états (visibility FSM)
    level: DEBUG
    handlers: [console]
    propagate: no

  igt.queues.gpu_buffers:  # sous-module GPU buffers
    level: DEBUG
    handlers: [console]
    propagate: no

  igt.slicer_server:  # serveur TX simulé (pyigtl)
    level: INFO
    handlers: [console]
    propagate: no

  igt.gateway.stats:  # statistiques gateway (latences RX→TX)
    level: DEBUG  # ✅ ACTIVER DEBUG pour voir les logs mark_rx/mark_tx
    handlers: [console]
    propagate: no

  igt.gateway.test:  # tests gateway (dataset mock, etc.)
    level: DEBUG  # ✅ ACTIVER DEBUG pour voir tous les détails du test
    handlers: [console]
    propagate: no

  igt.gateway.supervisor:  # thread de supervision (heartbeat, monitoring, autotune)
    level: INFO
    handlers: [pipeline_file]  # logs normaux dans pipeline, pas dans error
    propagate: no

  igt.plus_client:  # client de réception IGTLink (PlusServer)
    level: INFO
    handlers: [console, pipeline_file, error_file]  # logs normaux dans console/pipeline, erreurs dans error.log
    propagate: no
    

# ─────────────────────────────────────────────────────────────
# LOGGER RACINE
# ─────────────────────────────────────────────────────────────
root:
  level: WARNING  # niveau minimal par défaut (seulement warnings et erreurs)
  handlers: [console]  # affiche uniquement dans la console